# Netty

Netty是什么？为什么要用netty？

    Netty是有 JBoss提供的一个 java 开源框架
    Netty提供异步的、事件驱动的网络应用程序框和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序
    
    互联网公司必备: http://netty.io/wiki/adopters.html

    netty版本带来的问题: netty5-alpha已停止维护，现在都使用 netty4
    
## 第一个 netty 程序

netty核心组件初步了解

- channel
- 回调和 future
- 事件和 ChannelHandler

注意 channelRead 和 channelReadComplete 事件的调用

    如果缓冲区过小而用户数据过大，可能会多次complete之后一次read，多次收到数据后组成一个用户数据包
    如果缓冲区比用户数据大，可能会一次complete多次read，因为一包数据中含有多个用户数据

```java
public class EchoServerHandler extends ChannelInboundHandlerAdapter {
    
    /**
     * 读取到完整的用户数据时触发
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ByteBuf buffer= (ByteBuf) msg;
        System.out.println("Server accept: "+buffer.toString(CharsetUtil.UTF_8));
        ctx.write(buffer);
    }

    /**
     * 读取完缓冲区的数据之后触发 complete 事件
     * */
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        // 强制把缓冲区的数据刷到对端
        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)
                // 关闭连接
                .addListener(ChannelFutureListener.CLOSE);
    }
}
```

## channel的生命周期

- 未注册：channel已经创建出来，但还未跟EventLoop关联
- 已注册：已注册到 EventLoop
- 活动：已经和对端连接了
- 未连接：未和对端连接

## Channel组件再了解

- Channel -> socket
- ChannelFuture -> 异步通知
- EventLoop -> 控制、多线程处理、并发(EventLoop是一个只有一个线程的线程池)
- EventLoopGroup -> 线程池组

关系说明：

- 一个EventLoopGroup包含一个或者多个EventLoop
- 一个EventLoop在它的生命周期内只和一个Thread绑定
- 所有由 EventLoop 处理的 IO 事件都将在它专有的 Thread 上被处理
- 一个 Channel 在它的生命周期内只注册一个 EventLoop
- 一个 EventLoop 可能会被分配给一个或多个 Channel

ChannelHandler、ChannelPipeline和ChannelHandlerContext

- ChannelHandler，从应用程序开发人员来看，Netty的主要组件是ChannelHandler，它充当了所哟剢入站和出站数据的应用程序逻辑的地方。Nett有以适配器类的形式提供了大量默认的ChannelHandler实现，帮我们简化应用程序处理逻辑的开发过程。
- ChannelPipeline，提供了ChannelHandler链的容器，并定义了用于在该链上传播入站和出站事件流的api
- ChannelHandlerContext，当ChannelHandler被添加到ChannelPipeline时，它将被分配一个ChannelHandlerContext，其代表了ChannelHandler和ChannelPipeline之间的绑定

ChannelHandler的生命周期

- handlerAdded
- handlerRemoved
- exceptionCaught
…………

ChannelPipeline

    Netty会把出站handler和入站handler放到一个pipeline钟，屋里视图上看是一个，逻辑视图上看是两个
    在逻辑视图的角度，分属出站和入站不同的handler是无所谓顺序的
    而同属一个方向的handler则是有序的，因为上一个handler处理的结果往往是下一个handler要求的输入
    
ChannelHandlerContext

    当把ChannelHandler添加到ChannelPieline时，ChannelHandlerContext将会被创建
    尽量使用context提供的flush方法刷数据到对端，此方法不会从头扫描pipeline
    
    ctx.fireXXXX系列，往后传递事件(如果多个handler都在处理某个事件的话，必须要手动传递，否则后面的handler收不到事件)
    
选择合适的内置通讯传输模式

- NIO
- Epoll，只能在linux中运行，不能在windows中（水平触发、边缘触发）
- OIO(Old IO) = BIO
- Local
- Embedded，单元测试用

引导 bootstrap 和 ChannleOption