# JVM的执行子系统

## Class类文件结构

### JVM 的无关性

    - 平台无关性：一次编写，到处运行
    - 语言无关性：字节码(byte-code)
    
    java程序(.java) -> javac编译器           -->
    jruby程序(.rb)  -> jrubyc编译器          -->  字节码(.class)  -> java虚拟机
    groovy程序(.groovy) -> groovyc编译器     -->
    其他语言程序     -> 对应的编译器           -->
    
### Class类文件(字节码)

    - class文件是一组以 8 位字节为基础单位的二进制流
    - 类似于结构体的伪结构来存储数据
    - 只有两种数据类型：无符号数和表
    - 无符号数属于基本的数据类型，以u1、u2、u4、u8来表示
    - 表是由多个无符号数或者其他表座位数据项构成的复合数据类型
    
### Class文件格式详解

    - 魔数与Class文件的版本 
        魔数：(CA FE BA BE)
        版本：(00 00 00 34) 0x34 = 52 = 52 - 45 = 7 = 1.1 + 7 = 1.8，版本向前兼容
    - 常量池：两大常量：字面量、符号引用(全限定名)
    - 访问标志
    - 类索引、父类索引与接口索引
    - 字段表集合
    - 方法表集合
    - 属性表集合

## 字节码指令

### 简介和重要性

### 指令和数据类型

### 指令分类

    - 加载和存储指令
    - 运算指令
    - 类型转换指令
    - 对象创建与访问指令
    - 操作数栈管理指令(iload/istore)
    - 控制转移指令(ifeq)
    
## 虚拟机栈再认识

### 运行时的栈帧结构

    - 局部变量表：存储 8 大基础数据类型，32位的数据(slot)。如果存放 64 位(double)数据则分高 32 位和低 32 位
        boolean
        char
        byte
        int
        short
        long
        float
        double(reference)
        
    - 操作数栈，有重叠区域
        局部变量表中，栈帧 n 的结果有可能是栈帧 n-1 的入参，JVM 就会把它们重叠以节省空间
        
    - 动态连接
        多态：执行方法 -> 是哪个方法(有的类中方法地址编译期间无法确定) -> 引用(符号引用): 指向某个具体方法
            如：
            demo.kin方法 代号：com/enjoy/demo.king()  V (解析)
            静态解析：类加载的时候，第一个使用的V -> 00000013指向地址
            动态链接：必须在运行期间，才进行转换，V -> 00000016
            
    - 方法返回地址
        正常退出 -> 程序计数器(PC计数器)
        异常退出 -> 异常处理表(try catch)，栈帧不会去保存
        
## 基于栈的字节码解释执行引擎

### 基于栈的指令集与基于寄存器的指令集

    1 + 1 的例子：
    基于栈的指令集：虚拟机用
        iconst_1：常量 1 入栈
        iconst_1：常量 1 入栈
        iadd    ：栈顶的 2 个数相加并入栈
        istore_1：栈顶出栈并村存储到本地变量表 1 中
    基于寄存器的指令集，物理机用，优点：快，缺点：移植性差
        mov eax 1: 寄存器 eax 中放入1
        add eax 1: 寄存器 eax 中加1

### 基于栈的解释器执行过程、分析下面这段代码在虚拟机中的执行情况

## 字节码执行引擎 ———— 方法调用详解

### 解析

### 分派

    静态分派：重载
    动态分派：多态
    动态分派的实现
    
## 类加载机制

### 类加载过程详解
    
    - 初始化的 5 中情况
    
    字节码
    类加载
        加载（load)
            1、获取一个类的二进制字节流（通过一个类全限定名获取）
            2、字节流所代表的静态的存储结构转化成方法区的运行时数据结构
            3、入口：在内存中生成一个代表这个类的java.lang.Class对象，作为方法去这个类的各种数据的访问入口
        连接(link)
            1、验证：格式验证、元数据验证、字节码的验证等
            2、准备：初始化、零值设定(int: 0; boolean: false等)
            3、解析：静态解析，替换方法地址
        初始化(init)：类加载的最后一步，类构造器(无参构造)
            JVM 只识别字节码
            哪 5 种情况下会进行类初始化
                1、遇到 new 字节码的时候，getstatic、putstatic、invokestatic字节码
                2、反射：reflect，反射时类还未初始化时
                3、初始化一个类，如果发现父类还没有初始化，触发父类的初始化
                4、JVM启动时，指定执行主类的 main 的那个类，JVM 会初始化主类
                5、JDK 1.7以后，动态语言支持，java.lang.invoke.MethodHandler实例化类
                
            静态代码块，有多线程问题，初始化过程：一定是线程安全的
        使用
        卸载
    解释执行   ———— CPU
    JIT编译   ———— 机器码
    
## 类加载器

### 什么是类加载器？

    对任意一个类来说，确定他的唯一性：类的全限定名 + 类加载器
    类的equals、instanceof都会判断全限定名和类加载器
    
    - 用途：热加载、代码保护和加解密、类层次划分、OSGi等
    
    类加载器的加解密过程：
        - 框架代码不想给别人源码(但可以给人用)，class(jar)加密，反编译工具-MD5
        类加载器中进行了解密
        
## 双亲委派模型

    双亲委派模型过程：
        某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依此递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。
    双亲委派模型的好处：
        Java 类随着他的类加载器一起具备了带有优先级的层次关系，保证 java 程序稳定运行

    1、Bootstrap ClassLoader(启动类加载器) ————> jre/lib/*.jar, rt.jar/jce.jar等
    2、Extenstion ClassLoader(扩展类加载器) ————> jre/lib/ext/*.jar
    3、Application ClassLoader(应用程序类加载器) ————> CLASSPATH
        User ClassLoader1自定义类加载器
        User ClassLoader2
        
## Tomcat 类加载机制

### Tomcat类加载机制

    Tomcat容器下的两个应用以及tomcat的lib目录中都有UserServiceIpl类
    Tomcat怎么样保证类的隔离性？
        使用了多个WebApp ClassLoader来保证类的隔离