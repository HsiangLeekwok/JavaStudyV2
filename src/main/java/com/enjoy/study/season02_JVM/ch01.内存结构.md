# 虚拟机的前世今生 深入理解JVM内存区域

## 从虚拟机的发展到未来的技术发展

### 为什么要了解虚拟机

    1、写出更好、更优雅的Java程序
    2、排查问题，Java应用性能优化
    3、面试必问
    
### 虚拟机的发展

    HotSpot VM（Sum公司），以前使用范围最广的Java虚拟机
    JRockit VM（Bea），号称世界上最快的Java虚拟机
    J9 VM（IBM）
    Dalvik VM（Google）
    
    HotSpot VM（Oracle），目前使用范围最广的Java虚拟机
    
### 未来的Java技术

    模块化
    混合语言
    多核并行
    丰富语法
    64位
    更强的垃圾回收
    
### JVM的整体介绍

    类加载
    JVM（运行时数据区（内存））
        内存分配
        垃圾回收
    执行引擎
    机器码
    
### 运行时数据区
    
    JVM在运行过程中会把它所管理的内存划分成若干不同的数据区域
    - 线程私有(运行指令的)：程序计数器、虚拟机栈、本地方法栈
        
        程序计数器(虚拟机中唯一不会OOM的区域)：指向当前线程正在执行的自己吗指令的地址（行号）
            为什么需要程序计数器（面试）？
                - Java是多线程的，意味着线程切换
                - 确保多线程情况下的程序正常执行
                
        栈(Stack)：数据结构
            入口和出口只有一个
            入栈
            出栈
            
            特点：先进后出（FILO）
            为什么JVM要使用栈？
            
        虚拟机栈（大小设置 -Xss1M）：存储 当前线程 运行方法所需的数据、指令、返回地址
            栈帧：每个方法在执行的同时都会床ijanyige栈帧
                栈帧可以再划分为：
                    局部变量表
                    操作数栈
                    动态连接
                    返回地址
                    
        本地方法栈：native方法（底层C++方法）
            本地方法栈保存的是native方法的信息，当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机栈中创建栈帧，JVM只是简单的动态链接并直接调用native方法
    
    - 线程共享(数据)：堆、方法区
        
        方法区（永久代，元空间）
            类信息
            常量
            静态变量
            及时编译期编译后的代码
        Java堆（-Xms/-Xmx/-Xmn）：堆是需要中断关注的一块区域，因为涉及到内存的分配(new关键字、反射等)与回收(回收算法、收集器等)
            几乎所有的对象都是在堆中分配

### JVM个版本内存区域的变化

#### 运行时常量池

class文件中的常量池（编译器生成的各种字面量和符号引用）会在类价在后被放入这个区域

    符号引用
    字面量
    
JDK1.6 运行时常量池在方法区中

JDK1.7 运行时常量池在堆中

JDK1.8 去永久代，使用元空间(元空间大小只受制于及其的内存)替代永久代

    永久代参数：-XX:PermSize, -XX:MaxPermSize
    元空间参数：-XX:MetaspaceSize, -XX:MaxMetaspaceSize
    
    why?
    永久代用来村粗类信息、常量、静态变量等数据不是个好主意很容易遭遇到内存溢出的问题
    对永久代进行调优是很款男的，同时将元空间与堆的垃圾回收进行了隔离，皮面永久代引发的Full GC 和OOM等问题
   
### 直接内存 —— JVM直接管理不了的

直接内存：不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域

    - 如果使用了nio，这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作
    - 这块内存不受java堆大小限制，但受本机总内存的限制，可以通过MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常
    - 避免了在java堆和native堆中来回复制数据，能够提高效率
    
## SE技术体系以及JVM整体认识

## 玩转堆和栈的内存结构

## 虚拟机栈执行过程全揭秘

## 深入辨析堆和栈