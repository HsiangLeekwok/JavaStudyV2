# 618技术前瞻 怎么让缓存稳如磐石？

### 大促活动的后遗症：海量数据的查询不一样的问题

    2018双十一，一天累计成交额2k亿，物流单超10亿
    2017年圆通订单业务、圆通速递全年营业收入199.82亿，圆通速递全年业务完成量为50亿件
    
    不一样的问题：
        如果用户玩恶作剧，胡乱输入快递单号查询，会造成缓存击穿
        
**缓存击穿**：是指查询一个一定不存在的数据，这样的请求都要到存储层去查询，失去了缓存的意义。在流量大的时候，可能 DB 就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是**漏洞**。
    
    让请求落在缓存和DB之前将非法的key值进行过滤
    
    一个SQL语句执行时间超过300ms的话，需要优化、调整
    一个页面的响应时间在2s以上，则体验非常差

### 终极利器：算法解析

布隆过滤器(Bloom Filter)：是1970年由布隆提出的，布隆过滤器可以用于快速检索一个元素是否存在一个集合中，因此它是一个控件效率极高的概率型算法；它实际上是一个很长的二进制向量和一系列随机映射函数。

    算法优势：
        仅仅保留数据的指纹信息，空间效率极高
        查询效率极高，时间复杂度为：O(n)，随机函数有几个就n*几
        信息安全性较高
        
    算法不足：
        存在一定的误判
        数据删除困难
        
    经典场景：
        字处理软件中，需要检查一个英语单词是否贫血正确(100w个)
        在FBI，一个嫌疑人的名字是否已经在嫌疑名单上(100w)
        在网络爬虫里，一个网址是否被访问过(5亿个网站)
        
        -> 本质是快速判断一个数据是否存在于海量数据直中

### 完美解决缓存击穿：为缓存增加一道防火墙

    手把手教你使用布隆过滤器：站在巨人的肩膀上，别重复造轮子，Google Guava实现了布隆过滤器
        深入guava源码
        通过实战手把手教你布隆过滤器的使用
        
        put
        mightContain
        create
        
    遗留问题：
        数据量过大，初始化耗时过长 -------------------> Java并发编程分而治之的思想
        保证数据的一致性 ----------------------------> 解决复杂的互联网技术难题
        分布式环境，如何提供一个高可用的BL服务？ -------> 微服务搭建高可靠的服务能力
        Guava源码分析不尽兴 -------------------------> 更应该注重源码框架
        缓存的使用还有没有其他的坑？ ------------------> 缓存的使用水平决定了你的薪水